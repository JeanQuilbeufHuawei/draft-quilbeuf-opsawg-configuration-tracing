<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-model href="rfc7991bis.rnc"?>
<!-- <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?> -->
<rfc
        xmlns:xi="http://www.w3.org/2001/XInclude"
        category="std"
        ipr="trust200902"
        obsoletes=""
        updates=""
        submissionType="IETF"
        xml:lang="en"
        tocInclude="true"
        sortRefs="true"
        symRefs="true"
        version="3" >
<front>
    <title abbrev="Configuration Tracing via tx-id">External Transaction ID for Configuration Tracing</title>
    <seriesInfo name="Internet-Draft" value="draft-quilbeuf-opsawg-configuration-tracing-00"/>
    <author fullname="Jean Quilbeuf" initials="J" surname="Quilbeuf ">
      <organization>Huawei</organization>
      <address>
        <email>jean.quilbeuf@huawei.com</email>
      </address>
    </author> 
    <author fullname="Benoit Claise" initials="B" surname="Claise">
      <organization>Huawei</organization>
      <address>
        <email>benoit.claise@huawei.com</email>
      </address>
    </author>
    <date year="2022" month="8" day="30"/>
    <area>General</area>
    <workgroup>OPSAWG</workgroup>
    <abstract>
      <t>
        Network equipments are often configured by a variety of network management systems (NMS), protocols, and people.
        If a network issue arises because of a wrong configuration modification, it's important to quickly identify the specific service request and obtain the reason for pushing that modification.
        Another potential network issue can stem from concurrent NMS' with overlapping intent, each having their own tasks to perform: in such a case, it's important to map the respective modifications to its originating NMS.
        We propose a mechanism to automatically map the configuration modifications to their source, up to a specific NMS service request.
        Such a mechanism is required for autonomous networks, to trace the reason of a particular configuration change that lead to an anomaly detection or a broken SLA.
        This mechanism would facilitate the troubleshooting, the post mortem analysis, and in the end the closed loop automation required for self-healing networks.
        This document proposes a new YANG module mapping a local configuration change to the corresponding northbound transaction, up to the controller or even the orchestrator.
      </t>
    </abstract>
    <note removeInRFC="true">
      <name>Discussion Venues</name>
      <t>Source for this draft and an issue tracker can be found at
       <eref target="https://github.com/JeanQuilbeufHuawei/draft-collected-data-manifest"/>.</t>
    </note>
  </front>
  <middle>
    <section anchor="intro" >
      <name>Introduction</name>
      <t>
        Issues arising in the network, for instance violation of some SLAs, might be due to some configuration modification.
        In the context of automated networks, the software needs not only to identify and revert the problematic configuration modification, but also to make sure that it wont happen again and that the fix will not disrupt other services.
        To cover the last two points, it is imperative to understand the cause of the problematic configuration change.
        Indeed, the first point, making sure that the configuration modification will not be repeated, cannot be ensured if the cause for pushing the modification in the first place is not known.
        Ensuring the second point, not disrupting other services, requires as well knowing if the configuration modification was pushed in order to support new services.
        Therefore, we need to be able to trace a configuration modification on a device back to the reason that triggered that modification, for instance in a NMS.
      </t>
      <t>
        The same network element or NETCONF <xref target="RFC6241"/> server can be configured by different NMSs or NETCONF clients.
        If an issue arises, the starting point for investigation is likely to be the configuration modification on the devices supporting the impacted service.
        In the best case, there is a dedicated user for each client and the timestamp of the modification allows tracing the problematic modification to its cause.
        In the worst case, everything is done by the same user and some more tricks must be done to trace the problematic modification to its source.
      </t>
      <t>
        Our proposition is to annotate configuration changes on the configured element with sufficient information to unambiguously identify the corresponding transaction, if any, on the element that requested the configuration modification.
        We propose to reuse the concept of a NETCONF transaction ID from <xref target="I-D.lindblad-netconf-transaction-id"/> and augment it with an ID for the client.
        The information needed to do the actual configuration tracing is stored in a new YANG module that maps local configuration modification ID to both corresponding north- and southbound transaction ID.
        For northbound transactions, we additionally store the ID of the client.
      </t>
      <t> TODO announce plan</t>
    </section>
    <section anchor="terminology">
      <name>Terminology</name>
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.
      </t>
      <t>
        This document uses the terms client and server from <xref target="RFC6241"/>.
      </t>
      <t>
        This document uses the terms transaction and transaction id from <xref target="I-D.lindblad-netconf-transaction-id"/>.
      </t>
      <t>
        TODO: define or reuse existing definitions
      </t>
      <ul>
        <li>orchestrator</li>
        <li>controller</li>
        <li>network equipment</li>
        <li>commit (configuration), or equivalent</li>
        <li>NMS</li>
      </ul>
    </section>
    <section anchor="transaction-id-tracing">
      <name>Relying on Transaction-id to Trace Configuration Modifications</name>
      <section anchor="use-cases">
        <name>Use cases</name>
        <t>
          This document was written with autonomous networks in mind.
          We assume that an existing system monitoring or assurance system, such as described in <xref target="I-D.ietf-opsawg-service-assurance-architecture"/>, is able to detect that some issues in the network are due to a particular configuration modification.
          Here are the use cases for the proposed YANG module:
        </t>
        <ul>
          <li>Find out whether the offending configuration modification was triggered by a tracing-enabled client/NMS.</li>
          <li>Map the offending configuration modification id on a server/NE to a local configuration modification id on the client/NMS</li>
          <li>Recursively find the service request that eventually triggered the offending configuration modification</li>
        </ul>
      </section>
      <section>
        <name>Populating the YANG module</name>
        <t>
          In <xref target="I-D.lindblad-netconf-transaction-id"/>, the concept of a NETCONF transaction ID is proposed, to match the same mechanism from RESTCONF <xref target="RFC8040"/>.
          The goal of this document is to speed up the re-synchronization process between a client and a server, by using a common transaction ID.
          If the current transaction ID on the server is the same as the transaction ID known by the client, then both are synchronized.
          Otherwise, the client has to fetch again the configuration.
          The transaction ID can be applied to the whole configuration or to so-called versioned nodes.
          In the latter case, only versioned nodes for which the transaction ID differs need to be updated.
        </t>
        <t>
          Our proposed solution is to store, on the server, a mapping between the existing local commit id and the northbound and southbound transactions related to that local configuration change.
          The mapping is read only and populated by the server at configuration time as follows:
        </t>
        <ul>
          <li>
            Northbound transaction:
            If the server is configured by a client that supports configuration tracing, the client MUST send a transaction-ID and its own ID.
            The server stores both entries as respectively northbound transaction ID and northbound client ID, associated to the local configuration ID.
            If the client does not support configuration tracing, none of these entries are populated.
          </li>
          <li>
            Southbound transaction:
            If the server has to configure some other servers in response to a local configuration change, then it MUST generate
            a transaction ID, send it along with its ID to the configured servers, and save it as a southbound transaction ID.
          </li>
        </ul>
        <t>
          The two cases above are not mutually exclusive. A Controller can be configured by an Orchestrator and configure network equipment in turn.
          In that case, both the northbound transaction ID, shared with the Orchestrator and the southbound transaction ID, shared with the network equipment, are stored in the Controller.
          They are both associated to the corresponding configuration commit in the Controller.
        </t>
      </section>
      <section>
        <name>Using the YANG module</name>
        <t>
          The YANG module defined below enables tracing a configuration change in a Network Equipment back to its origin, for instance a service request in an orchestrator.
          To do so, the software doing the tracing should have for each NMS ID (as stored in northbound-client-id), access to some credentials enabling read access to the model.
          It should as well have access to the network equipment in which an issue is detected.
        </t>
        <ol>
          <li>
            Identify the commit id that created an issue.
            This step is not defined here, we assume that the software is able to do it.
          </li>
          <li>
            The software queries the NE for the northbound transaction-id and NMS id associated to the commit-id from step 1.
            If they are no results, or no associated northbound-transaction-id, the change was not done by NMS compatible with the present draft, and the investigation stops here (first use case).
          </li>
          <li>
            Otherwise, queries the NMS identified by the northbound-client-id found at the previous step, looking for matching for the northbound-transaction-id from the previous step with a southbound-transaction-id in the NMS. (Second use case)
          </li>
          <li>
            From that query, the software knows the local-commit-id on the NMS.
            If the local-commit-id is associated to a northbound-transaction-id, the software restarts at step 3.
          </li>
          <li>
            Finally, the local-commit-id points to the changes in topmost NMS that eventually triggered the problematic configuration in the network equipment.
            These changes are now available for further manual or automated analysis, such as analyzing the root cause of the issue.
          </li>
        </ol>
      </section>
    </section>
    <section anchor="yang-module">
      <name>YANG module</name>
      <t> We present in this section the YANG module for modelling the information about the configuration modifications. </t>
      <section anchor="module-tree">
        <name>Overview</name>
        <t> The tree representation <xref target="RFC8340"/> of our YANG module is depicted in <xref target="module-tree-fig"/> </t>
        <figure anchor="module-tree-fig" >
          <name>Tree representation of ietf-external-transaction-id YANG module</name>
          <artwork><![CDATA[
module: ietf-external-transaction-id
  +--ro external-transactions-id
     +--ro configuration-change* [local-commit-id]
        +--ro local-commit-id              string
        +--ro northbound-transaction-id?   ietf-netconf-txid:etag-t
        +--ro northbound-client-id         string
        +--ro southbound-transaction-id?   ietf-netconf-txid:etag-t
            ]]>
          </artwork>
        </figure>
        <t> 
          The local-commit-id represents the local id of the configuration changes.
          It can be used to retrieve the local configuration changes that happened during that transaction.
        </t>
        <t>
          The northbound-transaction-id should be present when the server is configured by a client supporting the external transaction ID.
          In that case, the northbound-client-id is mandatory.
          The value of both fields are sent by the client whenever it sends the configuration that trigger the changes associated to the local-commit-id.
        </t>
        <t>
          The southbound-transaction-id should be present when the current configuration change leads to the configuration of other devices.
          In that case, the southbound-transaction-id should be generated by the server (and unique among other southbound-transaction-id fields generated on this server), sent to the configured devices and saved in that field.
        </t>
      </section>
      
      <section anchor="module-code" >
        <name>YANG module ietf-external-transaction-id</name>
        <sourcecode name="ietf-external-transaction-id@2021-11-03.yang" type="yang" markers="true" ><![CDATA[
module ietf-external-transaction-id {
  yang-version 1.1;
  namespace
    "urn:ietf:params:xml:ns:yang:ietf-external-transaction-id";
  prefix ext-txid;

  import ietf-netconf-txid {
    prefix ietf-netconf-txid;
  }

  organization
    "IETF OPSAWG Working Group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/opsawg/>
     WG List:  <mailto:opsawg@ietf.org>
     Author:   Benoit Claise  <mailto:benoit.claise@huawei.com>
     Author:   Jean Quilbeuf  <mailto:jean.quilbeuf@huawei.com>
     Author:   Jan Linblad    <mailto:jlindbla@cisco.com>";
  description
    "This module enable tracing of configuration changes in an
     automated network. It stores the ID of the northbound
     transaction when the local device is configured by an enabled
     NMS, and the southbound transaction ID when the local device
     configures other devices.

     The main usage of this module is to map a local configuration
     change to a northbound transaction ID that can be retrieved as
     southbound transaction ID on the configuring NMS, or to map a
     southbound transaction ID to a northbound transaction ID on
     devices that are both configured and configuring other devices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.

     Copyright (c) 2021 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).
     This version of this YANG module is part of RFC XXXX; see the
     RFC itself for full legal notices.  ";

  revision 2021-11-03 {
    description
      "Initial revision";
    reference
      "RFC xxxx: Title to be completed";
  }

  container external-transactions-id {
    config false;
    description
      "Contains the IDs of configuration transactions that are
       external to the current device.";
    list configuration-change {
      key "local-commit-id";
      description
        "List of configuration changes, identified by their
         local-commit-id";
      leaf local-commit-id {
        type string;
        description
          "Id as saved by the server. Can be used to retrieve
           the corresponding changes using the server mechanism
           if available.";
      }
      leaf northbound-transaction-id {
        type ietf-netconf-txid:etag-t;
        description
          "External transaction ID, sent by the client, corresponding
           to a change initiated by a northbound NMS. There should be
           a corresponding entry on the NMS as a
           southbound-transaction-id that maps to the actual
           configuration commit that triggered the configuration of
           this server.

           This field is present only when the configuration was
           pushed by a compatible system.";
      }
      leaf northbound-client-id {
        when '../northbound-transaction-id';
        type string;
        mandatory true;
        description
          "ID of the client doing the modification, to further query
           information about the corresponding change.";
      }
      leaf southbound-transaction-id {
        type ietf-netconf-txid:etag-t;
        description
          "Transaction ID transmitted to southbound devices
           configured following the configuration change
           corresponding to local-commit-id. ";
      }
    }
  }
}
    ]]></sourcecode>
      </section>
    </section>

    <section anchor="security">
        <name>Security Considerations</name>
    </section>
    <section anchor="iana">
      <name>IANA Considerations</name>
      <t>
        This document includes no request to IANA.
      </t>
    </section>
    <section>
      <name>Contributors</name>
    </section>
    <section>
      <name>Open Issues / TODO</name>
      <ul>
        <li> Do we restrict to NETCONF or generalize to any automated configuration framework? For instance, should a NMS that would use CLI to configure be supported by this draft as well? </li>
        <li> Terminology: NMS? Orchestrator? Controller? NETCONF if we restrict to NETCONF? </li>
        <li> Is there an existing YANG module for storing the configuration changes? </li>
        <li>
          A given commit can actually contain several transaction IDs, so we probably need to update the model in order to support that.
          Itâ€™s also a question of which interface we open for the software to find the issue.
          If that software can work with versioned nodes then it could identify a specific transaction id, rather than the local commit id.
        </li>
        <li>
          Schema describing the configuration of a NE
        </li>
        <li>
          Schema describing the configuration of a Controller that further configures a NE
        </li>
        <li>
          Schema describing the configuration of a Controller that further configures a NE
        </li>
      </ul>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6241.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8340.xml"/>
    </references>
    <references title="Informative References">
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8040.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-lindblad-netconf-transaction-id-02.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-opsawg-service-assurance-architecture.xml"/>
    </references>
    <?rfc needLines="100"?>
    <section>
      <name>Changes between revisions</name>
      <t> Initial version
      </t>
    </section>
    <section anchor="usage">
      <name>Tracing configuration changes</name>
    </section>
    <section numbered="false">
      <name>Acknowledgements</name>
      <t>
          ...
        </t>
    </section>
  </back>
</rfc>
<!-- Local Variables: -->
<!-- fill-column:72 -->
<!-- End: -->