<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-quilbeuf-opsawg-configuration-tracing-00">
  <front>
    <title abbrev="Configuration Tracing via tx-id">External Transaction ID for Configuration Tracing</title>
    <author fullname="Jean Quilbeuf" initials="J" surname="Quilbeuf ">
      <organization>Huawei</organization>
      <address>
        <email>jean.quilbeuf@huawei.com</email>
      </address>
    </author> 
    <author fullname="Benoit Claise" initials="B" surname="Claise">
      <organization>Huawei</organization>
      <address>
        <email>benoit.claise@huawei.com</email>
      </address>
    </author>
    <author initials="J." surname="Lindblad" fullname="Jan Lindblad">
      <organization>Cisco Systems</organization>
      <address>
        <email>jlindbla@cisco.com</email>
      </address>
    </author>
    <date/>
    <area>OPS</area>
    <workgroup>OPSAWG</workgroup>
    <abstract>
      <t>
        Network equipments are often configured by a variety of network management systems (NMS), protocols and people.
        Each NMS might have its own task to perform and these tasks can overlap, leading to two different NMS reverting each other modifications on the same network equipment.
        Also, the configuration pushed by an NMS can be modified by an engineer or some protocol.
        In turn, this can bring services down and de-synchronize NMSs from their managed network equipment.
        We propose a mechanism to map the configuration modifications their source, up to the service request in the case of NMSs.
        Such a mechanism would facilitate the troubleshooting and post mortem analysis.
        Also, in case of more automated systems, the system could automatically identify two conflicting service requests, find a solution to the conflict and close the loop by sending new instructions to the conflicting NMSs.
        This document proposes a new YANG model to map a local configuration change to corresponding northbound and southbound transactions, if any.
        In the context of NETCONF, with compatible NMS, the model would also contain a reference provided by the NMS itself, to map back to the service request. 
      </t>
    </abstract>
  </front>
  <middle>
    <section title="Terminology" anchor="terminology">
      <t>
         The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
         NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
         "MAY", and "OPTIONAL" in this document are to be interpreted as
         described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
         when, and only when, they appear in all capitals, as shown here.
      </t>
      <t>
        TODO: define or reuse existing definitions
        <list>
          <t>client</t>
          <t>server</t>
          <t>orchestrator</t>
          <t>controller</t>
          <t>network equipment</t>
          <t>transaction</t>
          <t>transaction id</t>
          <t>commit (configuration), or equivalent</t>
          <t>NMS</t>
        </list>
      </t>
    </section>
    <section anchor="intro" title="Introduction">
      
      <!-- <t>
        This document focuses on cases where the network is configured by several NMS that use NETCONF  to update the configuration of the device.
        For instance, a network service orchestrator might receive on its northbound interface a service request to create a new service instance, following a service model <xref target="RFC8309"/> described using YANG <xref target="RFC6020"/>.  
        The orchestrator will then use NETCONF, as a client, to push the configuration needed to create the service.
        The configured network elements, which act as NETCONF servers, are likely to keep track of the modification as part of the commit history.
        However, the only information available about the configuration change usually contains is the username of the account that triggered the change, the date and the protocol used.
        In particular, the source of the modification is not available.
      </t>
      <t>
        In most cases, there isn't a single NMS configuring all the devices.
        Usually, engineer can log in directly to devices to modify the configuration.
        Some protocols can also alter the configuration.
        Finally, there are cases where several NMSs are concurrently configuring the devices.
      </t> -->

      <t> <!-- Troubleshooting network is involved when several NMS are used. -->
        When several NMSs are used to configure the network, the same network element or NETCONF <xref target="RFC6241"/> server can be configured by different NMSs or NETCONF clients.
        In that case, the configuration or services configured by the first client might be impacted by the configuration pushed by the second client.
        That impact is not always easy to detect, especially if the first client is not aware of the modification done by the second client and thus is in a correct state internally, so no NMS would report an error.
        If an issue arise, the starting point for investigation is likely to be the configuration modification on a given device.
        In the best case, there is a dedicated user for each client and the timestamp of the modification allows finding the reason why the second client did the modification.
        In the worst case, everything is done by the same user and some more tricks must be done to identify the source of the second modification.
      </t>
      <t>
        Two NMSs requesting different configurations for the same NE are in conflict.
        In order to enable automation, we need to be able to automatically detect such conflicts, analyze their cause and automatically arbitrate them at a higher level.
        While arbitration is outside of the scope of this document, finding out why the two NMSs are in conflict and possibly finding conflicting service requests is a good use case for this document.
        Our proposition is to annotate configuration changes on the configured element with sufficient information to unambiguously identify the corresponding transaction, if any, on the element that requested the configuration modification.
      </t>
      <t>
        In <xref target="I-D.lindblad-netconf-transaction-id"/>, the concept of a NETCONF transaction ID is proposed, to match the same mechanism from RESTCONF <xref target="RFC8040"/>.
        The goal of this document is to speed up the re-synchronization process between a client and a server, by using a common transaction ID.
        If the current transaction ID on the server is the same as the transaction ID known by the client, then both are synchronized.
        Otherwise, the client has to fetch again the configuration.
        The transaction ID can be applied to the whole configuration or to so-called versioned nodes.
        In the later case, only versioned nodes for which the transaction ID differs need to be updated.
      </t>
      <t>
        Our proposed solution is to store a mapping between the existing local commit id and the northbound and southbound transactions related to that local configuration change.
        The mapping is read only and populated by the server at configuration time.
      </t>
      <t>
        If the server is configured by an enabled client, then the client must send a transaction-ID and its own ID.
        The server stores both as northbound transaction ID and corresponding client ID.
      </t>
      <t>
        If the server has to configure some other servers in response to a local configuration change, then it generates
        a transaction ID, sends it along with its ID to the other servers, and saves it as a southbound transaction ID.
      </t>
      <t>
        The two cases above are not mutually exclusive. A controller can be configured by an Orchestrator and configure network equipment in turn.
        In that case, both the northbound transaction ID, shared with the orchestrator and the southbound transaction ID, shared with the network equipments, are stored.
        They are both associated to the corresponding local configuration commit.
      </t>
    </section>

    <section anchor="yang-module" title="YANG Module">
      <t> We present in this section the YANG module for modelling the information about the configuration modifications. </t>
      <section anchor="module-tree" title="Overview">
        <t> The tree representation <xref target="RFC8340"/> of our YANG module is depicted in <xref target="module-tree-fig"/> </t>
        <figure anchor="module-tree-fig" title="Tree representation of ietf-external-transaction-id YANG module">
          <artwork><![CDATA[
{{ external_transaction_id_tree }}
            ]]>
          </artwork>
        </figure>
        <t> 
          The local-commit-id represents the local id of the configuration changes.
          It can be used to retrieve the local configuration changes that happened during that transaction.
        </t>
        <t>
          The northbound-transaction-id should be present when the server is configured by a client supporting the external transaction ID.
          In that case, the northbound-client-id is mandatory.
          The value of both fields are sent by the client whenever it sends the configuration that trigger the changes associated to the local-commit-id.
        </t>
        <t>
          The southbound-transaction-id should be present when the current configuration change leads to the configuration of other devices.
          In that case, the southbound-transaction-id should be generated by the server (and unique among other southbound-transaction-id fields generated on this server), sent to the configured devices and saved in that field.
        </t>
      </section>
      
      <section anchor="module-code" title="YANG module ietf-external-transaction-id">
        <t>&lt;CODE BEGINS&gt; file "ietf-external-transaction-id@2021-11-03.yang"</t>
        <figure>
          <artwork><![CDATA[
{{ external_transaction_id_yang }}
    ]]></artwork>
        </figure>
        <t>&lt;CODE ENDS&gt;</t>
      </section>
    </section>

    <section anchor="security" title="Security Considerations">
    </section>
    <section anchor="iana" title="IANA Considerations">
      <t>
        This document includes no request to IANA.
      </t>
    </section>
    <section title="Contributors">
    </section>
    <section title="Open Issues">
      <t>
        <list>
          <t> Do we restrict to NETCONF or generalize to any automated configuration framework? For instance, should a NMS that would use CLI to configure be supported by this draft as well? </t>
          <t> Terminology: NMS? Orchestrator? Controller? NETCONF if we retrict to NETCONF? </t>
          <t> Is there an existing YANG module for storing the configuration changes? </t>
        </list>
      </t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.6020"?>
      <?rfc include="reference.RFC.6241"?>
      <?rfc include="reference.RFC.8174"?>
      <?rfc include="reference.RFC.8340"?>
    </references>
    <references title="Informative References">
      <?rfc include="reference.RFC.8040"?>
      <?rfc include="reference.RFC.8199"?>
      <?rfc include="reference.RFC.8309"?>
      <?rfc include="reference.I-D.draft-lindblad-netconf-transaction-id-00"?>
    </references>
    <?rfc needLines="100"?>
    <section title="Changes between revisions">
      <t> Initial version
      </t>
    </section>
    <section anchor="usage" title="Tracing configuration changes">
      <t>
        The model above enables tracing a configuration change in a Network Equipment back to its origin, for instance a service request in an orchestrator.
        To do so, the software doing the tracing should have for each NMS ID (as stored in northbound-client-id), access to some credentials enabling read access to the model.
        It should as well have access to the network equipments in which an issue is detected.
      </t>
      <t>
        The first step is to identify the commit id that created an issue.
        This step is not defined here, we assume that the software is able to identify a commit id.
      </t>
      <t>
          The software can match the commit-id with the local-commit-id of our model.
          If they are no results, or no associated northbound-transaction-id, the change was not done by NMS compatible with the present draft, and the investigation stops here.
      </t>
      <t>
        Otherwise, the software connects to the NMS identified by the northbound-client-id.
        The software looks for the northbound-transaction-id from the previous step in the southbound-transaction-id of the NMS.
      </t>
      <t>
        From that query, the software knows the local-commit-id on the NMS.
        If the local-commit-id is associated to a northbound-transaction-id, the software can iterate the previous step with the NMS identified by the northbound-client-id field.
      </t>
      <t>
        Finally, the local-commit-id points to the changes in topmost NMS that eventually triggered the problematic configuration in the network equipment.
        These changes are now available for further manual or automated analysis.
      </t>
    </section>
    <section title="Acknowledgements" numbered="no">
      <t>
          ...
        </t>
    </section>
  </back>
</rfc>
<!-- Local Variables: -->
<!-- fill-column:72 -->
<!-- End: -->
